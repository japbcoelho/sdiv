\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{divdiagram}[2025/12/06 v1.3.0 Division Diagram Package]

% Author: Joao Alberto Coelho
% Email: japbcoelho@proton.me
% License: LPPL 1.3c
% Description: Package for drawing successive division diagrams

\RequirePackage{tikz}
\RequirePackage{luacode}
\RequirePackage[normalem]{ulem}

\begin{luacode*}
-- Layout constants (in em units)
local CHAR_WIDTH = 0.55              -- Approximate width per character
local NODE_INNER_SEP = 0.3333        -- Default TikZ node inner sep
local CIRCLE_INNER_SEP = 0.2         -- Default inner sep for circles
local BASE_GAP = 0.3                 -- Base gap between elements
local CIRCLE_PADDING = 0.1           -- Extra padding around circles
local BAR_END_PADDING = 0.5          -- Padding at end of last bar
local BAR_VERTICAL_OFFSET = 0.5      -- Vertical offset for horizontal bars
local ARROW_OFFSET_Y = 1.05          -- Vertical offset for arrow
local ARROW_OFFSET_X = 0.5           -- Horizontal offset for arrow
local FIXED_GAP = 0.2                -- Fixed gap between numbers and bars

-- Perform successive division algorithm
-- Returns table of {quotient, remainder} pairs
-- max_iterations: optional limit on number of divisions (nil = no limit)
function successive_division(dividend, divisor, max_iterations)
    local results = {}
    local current = dividend
    local iterations = 0

    while current >= divisor do
        -- Check if we've reached the iteration limit
        if max_iterations and iterations >= max_iterations then
            break
        end

        local quotient = math.floor(current / divisor)
        local remainder = current % divisor
        table.insert(results, {quotient = quotient, remainder = remainder})
        current = quotient
        iterations = iterations + 1
    end

    -- Handle case where dividend < divisor
    if #results == 0 then
        table.insert(results, {quotient = 0, remainder = dividend})
    end

    return results
end

-- Main drawing function
-- dividend: non-negative integer
-- divisor: positive integer
-- options: comma-separated string (e.g., "circle,arrow" or "0.5,arrow,stop=2")
--   Available options:
--     circle, highlight: draw circles around remainders
--     uline: underline last quotient and remainder
--     arrow: show reading direction arrow
--     stop=N: stop after N divisions (default: continue until complete)
--     numeric value: custom inner sep for circles
function draw_division(dividend, divisor, options)
    -- Validate dividend is integer
    if math.floor(dividend) ~= dividend then
        tex.error("Dividend must be an integer, received: " .. tostring(dividend))
        return
    end

    -- Validate divisor is integer
    if math.floor(divisor) ~= divisor then
        tex.error("Divisor must be an integer, received: " .. tostring(divisor))
        return
    end

    -- Validate divisor is not zero
    if divisor == 0 then
        tex.error("Divisor cannot be zero")
        return
    end

    -- Validate dividend is non-negative
    if dividend < 0 then
        tex.error("Dividend must be non-negative, received: " .. tostring(dividend))
        return
    end

    -- Validate divisor is positive
    if divisor <= 0 then
        tex.error("Divisor must be positive, received: " .. tostring(divisor))
        return
    end

    -- Parse options
    local opts = options or ""
    local highlight = opts:match("%f[%a]highlight%f[%A]") ~= nil or opts:match("%f[%a]circle%f[%A]") ~= nil
    local use_uline = opts:match("%f[%a]uline%f[%A]") ~= nil
    local arrow = opts:match("%f[%a]arrow%f[%A]") ~= nil

    -- Parse stop option (stop=N)
    local stop_at = opts:match("stop%s*=%s*(%d+)")
    local max_iterations = nil
    if stop_at then
        max_iterations = tonumber(stop_at)
        if not max_iterations or max_iterations < 1 then
            tex.error("stop value must be a positive integer, received: " .. tostring(stop_at))
            return
        end
    end

    -- Perform successive division
    local results = successive_division(dividend, divisor, max_iterations)
    local n = #results

    -- Check for custom inner sep (standalone numeric value in options)
    -- Match a number that is NOT part of a key=value pair
    local custom_inner_sep = nil
    -- Split options by comma and check each token
    for token in (opts .. ","):gmatch("([^,]*),") do
        token = token:match("^%s*(.-)%s*$")  -- trim whitespace
        -- Check if token is purely numeric (not a key=value pair)
        if token:match("^[%d%.]+$") and not token:match("=") then
            custom_inner_sep = token
            break
        end
    end

    local circle_inner_sep = CIRCLE_INNER_SEP

    -- If 'circle' option is used without a numeric value, default to 0.25
    if highlight and not custom_inner_sep then
        circle_inner_sep = 0.25
    elseif custom_inner_sep then
        local value = tonumber(custom_inner_sep)
        if value and value > 0 then
            circle_inner_sep = value
            highlight = true  -- Auto-enable circles if number specified
        end
    end

    -- Calculate widths
    local dividend_width = string.len(tostring(dividend)) * CHAR_WIDTH
    local divisor_width = string.len(tostring(divisor)) * CHAR_WIDTH

    -- Calculate maximum circle radius for layout spacing
    local max_circle_extra = 0
    if highlight then
        for i = 1, n do
            local rem_width = string.len(tostring(results[i].remainder)) * CHAR_WIDTH
            local rem_radius = rem_width / 2 + circle_inner_sep
            max_circle_extra = math.max(max_circle_extra, rem_radius)
        end
        local last_quot_width = string.len(tostring(results[n].quotient)) * CHAR_WIDTH
        local last_quot_radius = last_quot_width / 2 + circle_inner_sep
        max_circle_extra = math.max(max_circle_extra, last_quot_radius)
    end

    local circle_gap = math.max(BASE_GAP, max_circle_extra + CIRCLE_PADDING)

    -- FIRST PASS: Calculate maximum width for each column to ensure alignment
    local max_column_widths = {}

    -- Column 1: dividend and first remainder
    local col1_width = math.max(dividend_width, string.len(tostring(results[1].remainder)) * CHAR_WIDTH)
    max_column_widths[1] = col1_width

    -- Subsequent columns: quotient from previous step and remainder from current step
    for i = 2, n do
        local prev_quot_width = string.len(tostring(results[i-1].quotient)) * CHAR_WIDTH
        local curr_rem_width = string.len(tostring(results[i].remainder)) * CHAR_WIDTH
        max_column_widths[i] = math.max(prev_quot_width, curr_rem_width)
    end

    -- Last column: just the last quotient
    local last_quot_width = string.len(tostring(results[n].quotient)) * CHAR_WIDTH
    max_column_widths[n+1] = last_quot_width

    -- Calculate positions of vertical bars based on maximum column widths
    local bar_positions = {}
    local column_centers = {}  -- Store the center x-position of each column

    -- First bar position
    local left_space = max_column_widths[1]
    if highlight then
        left_space = math.max(left_space, max_column_widths[1] / 2 + max_circle_extra + CIRCLE_PADDING)
    end
    bar_positions[1] = left_space + FIXED_GAP
    column_centers[1] = bar_positions[1] - FIXED_GAP - max_column_widths[1] / 2

    -- Subsequent bar positions
    for i = 2, n do
        local column_width = max_column_widths[i]

        if highlight then
            column_width = math.max(column_width, max_column_widths[i] / 2 + max_circle_extra + CIRCLE_PADDING)
        end

        bar_positions[i] = bar_positions[i-1] + FIXED_GAP + column_width + FIXED_GAP
        column_centers[i] = bar_positions[i-1] + FIXED_GAP + max_column_widths[i] / 2
    end

    -- Last column center (for last quotient)
    column_centers[n+1] = bar_positions[n] + FIXED_GAP + max_column_widths[n+1] / 2

    -- Begin TikZ picture
    tex.print("\\begin{tikzpicture}[every node/.style={minimum height=1.4em}, x=1em, y=1.4em]")

    -- Draw dividend (top left, aligned to first column center)
    tex.print(string.format("\\node at (%.2f, 0) (div) {%s};",
        column_centers[1], dividend))

    -- Draw each division step
    for i = 1, n do
        local quot = results[i].quotient
        local rem = results[i].remainder

        -- Draw divisor (aligned left at fixed distance from bar)
        tex.print(string.format("\\node[anchor=west] at (%.2f, %d) (d%d) {%s};",
            bar_positions[i] + FIXED_GAP, -(i-1), i, divisor))

        -- Draw remainder at column center (ALWAYS aligned with dividend)
        local rem_center_x = column_centers[i]

        if use_uline then
            tex.print(string.format("\\node at (%.2f, %d) (r%d) {\\uline{%s}};",
                rem_center_x, -i, i, rem))
        else
            tex.print(string.format("\\node at (%.2f, %d) (r%d) {%s};",
                rem_center_x, -i, i, rem))
        end

        -- Draw circle around remainder if highlighting
        if highlight then
            local rem_width = string.len(tostring(rem)) * CHAR_WIDTH
            tex.print(string.format("\\draw (r%d) circle[radius=%.3fem];", i,
                rem_width / 2 + circle_inner_sep))
        end

        -- Draw quotient (aligned left at same distance from bar as divisor)
        local is_last = (i == n)
        if use_uline and is_last then
            tex.print(string.format("\\node[anchor=west] at (%.2f, %d) (q%d) {\\uline{%s}};",
                bar_positions[i] + FIXED_GAP, -i, i, quot))
        else
            tex.print(string.format("\\node[anchor=west] at (%.2f, %d) (q%d) {%s};",
                bar_positions[i] + FIXED_GAP, -i, i, quot))
        end

        -- Draw circle around last quotient if highlighting
        if highlight and is_last then
            local quot_width = string.len(tostring(quot)) * CHAR_WIDTH
            tex.print(string.format("\\draw (q%d) circle[radius=%.3fem];", i,
                quot_width / 2 + circle_inner_sep))
        end
    end

    -- Draw vertical bars (L-shaped connections)
    for i = 1, n do
        if i < n then
            -- Intermediate bars connect to next bar
            tex.print(string.format("\\draw (d%d.north west) |- (d%d.north west);", i, i+1))
        else
            -- Last bar extends to the right
            -- Use the maximum column width for proper alignment
            local quot_right_x = column_centers[n+1] + max_column_widths[n+1] / 2
            local end_x = quot_right_x + BAR_END_PADDING

            -- Extend further if circles are present
            if highlight then
                end_x = column_centers[n+1] + max_circle_extra + BAR_END_PADDING
            end

            -- Ensure the bar extends at least to the end of the divisor
            local divisor_right_x = bar_positions[i] + FIXED_GAP + divisor_width
            end_x = math.max(end_x, divisor_right_x + BAR_END_PADDING)

            tex.print(string.format("\\draw (d%d.north west) |- (%.2f, %.2f);",
                i, end_x, -i + BAR_VERTICAL_OFFSET))
        end
    end

    -- Draw arrow (for base conversion reading direction)
    if arrow then
        -- Arrow starts below last quotient (using column center for alignment)
        local x1 = column_centers[n+1]
        local y1 = -n - ARROW_OFFSET_Y

        -- Goes horizontally left
        local x2 = bar_positions[n] - FIXED_GAP

        -- Then diagonally to below first remainder (using column center for alignment)
        local x3 = column_centers[1]
        local y3 = -1 - ARROW_OFFSET_Y

        tex.print(string.format("\\draw[->, thick] (%.2f, %.2f) -- (%.2f, %.2f) -- (%.2f, %.2f);",
            x1, y1, x2, y1, x3, y3))
    end

    -- End TikZ picture
    tex.print("\\end{tikzpicture}")
end
\end{luacode*}

% User command: \divdiagram[options]{dividend}{divisor}
% Options:
%   - circle, highlight: draw circles around remainders
%   - uline: underline last quotient and remainder
%   - arrow: show reading direction arrow
%   - stop=N: stop after N divisions (default: continue until complete)
%   - numeric value: custom inner sep for circles (e.g., 0.5)
\newcommand{\divdiagram}[3][]{%
    \directlua{draw_division(#2, #3, "#1")}%
}

% Backward compatibility alias
\let\sdiv\divdiagram

\endinput
