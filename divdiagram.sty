\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{divdiagram}[2025/12/06 v1.3.0 Division Diagram Package]

% Author: Joao Alberto Coelho
% Email: japbcoelho@proton.me
% License: LPPL 1.3c
% Description: Package for drawing successive division diagrams

\RequirePackage{tikz}
\RequirePackage{luacode}
\RequirePackage[normalem]{ulem}
\RequirePackage{xcolor}

\begin{luacode*}
-- Layout constants (in em units)
local CHAR_WIDTH = 0.55              -- Approximate width per character
local NODE_INNER_SEP = 0.3333        -- Default TikZ node inner sep
local CIRCLE_INNER_SEP = 0.2         -- Default inner sep for circles
local BASE_GAP = 0.3                 -- Base gap between elements
local CIRCLE_PADDING = 0.1           -- Extra padding around circles
local BAR_END_PADDING = 0.5          -- Padding at end of last bar
local BAR_VERTICAL_OFFSET = 0.5      -- Vertical offset for horizontal bars
local ARROW_OFFSET_Y = 1.05          -- Vertical offset for arrow
local ARROW_OFFSET_X = 0.5           -- Horizontal offset for arrow
local FIXED_GAP = 0.2                -- Fixed gap between numbers and bars

-- Perform successive division algorithm
-- Returns table of {quotient, remainder} pairs
-- max_iterations: optional limit on number of divisions (nil = no limit)
function successive_division(dividend, divisor, max_iterations)
    local results = {}
    local current = dividend
    local iterations = 0

    -- Special case: division by 1 always gives one step (quotient=dividend, remainder=0)
    if divisor == 1 then
        table.insert(results, {quotient = dividend, remainder = 0})
        return results
    end

    while current >= divisor do
        -- Check if we've reached the iteration limit
        if max_iterations and iterations >= max_iterations then
            break
        end

        local quotient = math.floor(current / divisor)
        local remainder = current % divisor
        table.insert(results, {quotient = quotient, remainder = remainder})
        current = quotient
        iterations = iterations + 1
    end

    -- Handle case where dividend < divisor
    if #results == 0 then
        table.insert(results, {quotient = 0, remainder = dividend})
    end

    return results
end

-- Main drawing function
-- dividend: non-negative integer
-- divisor: positive integer
-- options: comma-separated string (e.g., "circle,arrow" or "highlight=yellow,arrow=1.5,stop=2")
--   Available options:
--     circle: draw circles around remainders (default radius: 0.25)
--     circle=N: draw circles with custom radius N
--     highlight: add colorbox background to remainders (default: lightgray)
--     highlight=color: add colorbox with custom color
--     uline: underline last quotient and remainder
--     arrow: show reading direction arrow (default offset: 1.05)
--     arrow=N: show arrow with custom vertical offset N
--     stop=N: stop after N divisions (default: continue until complete)
function draw_division(dividend, divisor, options)
    -- Validate dividend is integer
    if math.floor(dividend) ~= dividend then
        tex.error("Dividend must be an integer, received: " .. tostring(dividend))
        return
    end

    -- Validate divisor is integer
    if math.floor(divisor) ~= divisor then
        tex.error("Divisor must be an integer, received: " .. tostring(divisor))
        return
    end

    -- Validate divisor is not zero
    if divisor == 0 then
        tex.error("Divisor cannot be zero")
        return
    end

    -- Validate dividend is non-negative
    if dividend < 0 then
        tex.error("Dividend must be non-negative, received: " .. tostring(dividend))
        return
    end

    -- Validate divisor is positive
    if divisor <= 0 then
        tex.error("Divisor must be positive, received: " .. tostring(divisor))
        return
    end

    -- Parse options
    local opts = options or ""
    local use_circle = opts:match("%f[%a]circle%f[%A]") ~= nil
    local use_highlight = opts:match("%f[%a]highlight%f[%A]") ~= nil
    local use_uline = opts:match("%f[%a]uline%f[%A]") ~= nil
    local arrow = opts:match("%f[%a]arrow%f[%A]") ~= nil

    -- Parse highlight option with optional color (highlight=color)
    local highlight_color = opts:match("highlight%s*=%s*([%a]+)")
    if highlight_color then
        use_highlight = true
    else
        -- Default color if highlight is used without a value
        if use_highlight then
            highlight_color = "lightgray"
        end
    end

    -- Parse arrow option with optional offset (arrow=N)
    local arrow_offset_value = opts:match("arrow%s*=%s*([%d%.]+)")
    local arrow_offset_y = ARROW_OFFSET_Y

    if arrow_offset_value then
        local value = tonumber(arrow_offset_value)
        if value and value > 0 then
            arrow_offset_y = value
            arrow = true  -- Enable arrow with custom offset
        else
            tex.error("arrow offset must be a positive number, received: " .. tostring(arrow_offset_value))
            return
        end
    end

    -- Parse stop option (stop=N)
    local stop_at = opts:match("stop%s*=%s*(%d+)")
    local max_iterations = nil
    if stop_at then
        max_iterations = tonumber(stop_at)
        if not max_iterations or max_iterations < 1 then
            tex.error("stop value must be a positive integer, received: " .. tostring(stop_at))
            return
        end
    end

    -- Perform successive division
    local results = successive_division(dividend, divisor, max_iterations)
    local n = #results

    -- Parse circle option with optional radius (circle=N)
    local circle_radius = opts:match("circle%s*=%s*([%d%.]+)")
    local circle_inner_sep = CIRCLE_INNER_SEP

    if circle_radius then
        local value = tonumber(circle_radius)
        if value and value > 0 then
            circle_inner_sep = value
            use_circle = true  -- Enable circles with custom radius
        else
            tex.error("circle radius must be a positive number, received: " .. tostring(circle_radius))
            return
        end
    elseif use_circle then
        -- If 'circle' option is used without a value, default to 0.25
        circle_inner_sep = 0.25
    end

    -- Calculate widths
    local dividend_width = string.len(tostring(dividend)) * CHAR_WIDTH
    local divisor_width = string.len(tostring(divisor)) * CHAR_WIDTH

    -- Calculate maximum circle radius for layout spacing
    local max_circle_extra = 0
    if use_circle then
        for i = 1, n do
            local rem_width = string.len(tostring(results[i].remainder)) * CHAR_WIDTH
            local rem_radius = rem_width / 2 + circle_inner_sep
            max_circle_extra = math.max(max_circle_extra, rem_radius)
        end
        local last_quot_width = string.len(tostring(results[n].quotient)) * CHAR_WIDTH
        local last_quot_radius = last_quot_width / 2 + circle_inner_sep
        max_circle_extra = math.max(max_circle_extra, last_quot_radius)
    end

    local circle_gap = math.max(BASE_GAP, max_circle_extra + CIRCLE_PADDING)

    -- FIRST PASS: Calculate maximum width for each column to ensure alignment
    local max_column_widths = {}

    -- Column 1: dividend and first remainder
    local col1_width = math.max(dividend_width, string.len(tostring(results[1].remainder)) * CHAR_WIDTH)
    max_column_widths[1] = col1_width

    -- Subsequent columns: quotient from previous step and remainder from current step
    for i = 2, n do
        local prev_quot_width = string.len(tostring(results[i-1].quotient)) * CHAR_WIDTH
        local curr_rem_width = string.len(tostring(results[i].remainder)) * CHAR_WIDTH
        max_column_widths[i] = math.max(prev_quot_width, curr_rem_width)
    end

    -- Last column: just the last quotient
    local last_quot_width = string.len(tostring(results[n].quotient)) * CHAR_WIDTH
    max_column_widths[n+1] = last_quot_width

    -- Calculate positions of vertical bars based on maximum column widths
    local bar_positions = {}
    local column_centers = {}  -- Store the center x-position of each column

    -- First bar position
    local left_space = max_column_widths[1]
    if use_circle then
        left_space = math.max(left_space, max_column_widths[1] / 2 + max_circle_extra + CIRCLE_PADDING)
    end
    bar_positions[1] = left_space + FIXED_GAP
    column_centers[1] = bar_positions[1] - FIXED_GAP - max_column_widths[1] / 2

    -- Subsequent bar positions
    for i = 2, n do
        local column_width = max_column_widths[i]

        if use_circle then
            column_width = math.max(column_width, max_column_widths[i] / 2 + max_circle_extra + CIRCLE_PADDING)
        end

        bar_positions[i] = bar_positions[i-1] + FIXED_GAP + column_width + FIXED_GAP
        column_centers[i] = bar_positions[i-1] + FIXED_GAP + max_column_widths[i] / 2
    end

    -- Last column center (for last quotient)
    column_centers[n+1] = bar_positions[n] + FIXED_GAP + max_column_widths[n+1] / 2

    -- Begin TikZ picture
    tex.print("\\begin{tikzpicture}[every node/.style={minimum height=1.4em}, x=1em, y=1.4em]")

    -- Draw dividend (top left, aligned to first column center)
    tex.print(string.format("\\node at (%.2f, 0) (div) {%s};",
        column_centers[1], dividend))

    -- Draw each division step
    for i = 1, n do
        local quot = results[i].quotient
        local rem = results[i].remainder

        -- Draw divisor (aligned left at fixed distance from bar)
        tex.print(string.format("\\node[anchor=west] at (%.2f, %d) (d%d) {%s};",
            bar_positions[i] + FIXED_GAP, -(i-1), i, divisor))

        -- Draw remainder at column center (ALWAYS aligned with dividend)
        local rem_center_x = column_centers[i]

        -- Format remainder with optional colorbox and/or underline
        local rem_text = tostring(rem)
        if use_highlight then
            rem_text = string.format("\\colorbox{%s}{%s}", highlight_color, rem_text)
        end
        if use_uline then
            rem_text = string.format("\\uline{%s}", rem_text)
        end

        tex.print(string.format("\\node at (%.2f, %d) (r%d) {%s};",
            rem_center_x, -i, i, rem_text))

        -- Draw circle around remainder if using circles
        if use_circle then
            local rem_width = string.len(tostring(rem)) * CHAR_WIDTH
            tex.print(string.format("\\draw (r%d) circle[radius=%.3fem];", i,
                rem_width / 2 + circle_inner_sep))
        end

        -- Draw quotient (aligned left at same distance from bar as divisor)
        local is_last = (i == n)

        -- Format quotient with optional colorbox and/or underline (only for last quotient)
        local quot_text = tostring(quot)
        if is_last then
            if use_highlight then
                quot_text = string.format("\\colorbox{%s}{%s}", highlight_color, quot_text)
            end
            if use_uline then
                quot_text = string.format("\\uline{%s}", quot_text)
            end
        end

        tex.print(string.format("\\node[anchor=west] at (%.2f, %d) (q%d) {%s};",
            bar_positions[i] + FIXED_GAP, -i, i, quot_text))

        -- Draw circle around last quotient if using circles
        if use_circle and is_last then
            local quot_width = string.len(tostring(quot)) * CHAR_WIDTH
            tex.print(string.format("\\draw (q%d) circle[radius=%.3fem];", i,
                quot_width / 2 + circle_inner_sep))
        end
    end

    -- Draw vertical bars (L-shaped connections)
    for i = 1, n do
        if i < n then
            -- Intermediate bars connect to next bar
            tex.print(string.format("\\draw (d%d.north west) |- (d%d.north west);", i, i+1))
        else
            -- Last bar extends to the right
            -- Use the maximum column width for proper alignment
            local quot_right_x = column_centers[n+1] + max_column_widths[n+1] / 2
            local end_x = quot_right_x + BAR_END_PADDING

            -- Extend further if circles are present
            if use_circle then
                end_x = column_centers[n+1] + max_circle_extra + BAR_END_PADDING
            end

            -- Ensure the bar extends at least to the end of the divisor
            local divisor_right_x = bar_positions[i] + FIXED_GAP + divisor_width
            end_x = math.max(end_x, divisor_right_x + BAR_END_PADDING)

            tex.print(string.format("\\draw (d%d.north west) |- (%.2f, %.2f);",
                i, end_x, -i + BAR_VERTICAL_OFFSET))
        end
    end

    -- Draw arrow (for base conversion reading direction)
    if arrow then
        -- Arrow starts below last quotient (right edge instead of center)
        local last_quot_width = string.len(tostring(results[n].quotient)) * CHAR_WIDTH
        local x1 = column_centers[n+1] + last_quot_width / 2
        local y1 = -n - arrow_offset_y

        -- Goes horizontally left
        local x2 = bar_positions[n] - FIXED_GAP

        -- Then diagonally to below first remainder (left edge instead of center)
        local first_rem_width = string.len(tostring(results[1].remainder)) * CHAR_WIDTH
        local x3 = column_centers[1] - first_rem_width / 2
        local y3 = -1 - arrow_offset_y

        tex.print(string.format("\\draw[->, thick] (%.2f, %.2f) -- (%.2f, %.2f) -- (%.2f, %.2f);",
            x1, y1, x2, y1, x3, y3))
    end

    -- End TikZ picture
    tex.print("\\end{tikzpicture}")
end
\end{luacode*}

% User command: \divdiagram[options]{dividend}{divisor}
% Options:
%   - circle: draw circles around remainders (default radius: 0.25)
%   - circle=N: draw circles with custom radius N (e.g., circle=0.5)
%   - highlight: add colorbox background to remainders (default: lightgray)
%   - highlight=color: add colorbox with custom color (e.g., highlight=yellow)
%   - uline: underline last quotient and remainder
%   - arrow: show reading direction arrow (default offset: 1.05)
%   - arrow=N: show arrow with custom vertical offset N (e.g., arrow=1.5)
%   - stop=N: stop after N divisions (default: continue until complete)
\newcommand{\divdiagram}[3][]{%
    \directlua{draw_division(#2, #3, "#1")}%
}

% Backward compatibility alias
\let\sdiv\divdiagram

\endinput
